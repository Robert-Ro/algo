# 分治法思想案例：二分查找

## 分治法的使用方法

应用前提条件需要原问题具备一下几个特征：

1. 难度在降低：即原问题的解决难度，随着数据规模的缩小而降低
2. 问题可分：原问题可分解为若干个规模较小的同类型问题
3. 解可合并：利用所有子问题的解，可合并出原问题的解
4. 相互独立：各个子问题之间相互独立，某个子问题的求解不会影响到另一个子问题(后一个子问题受前一个子问题影响：动态规划？)

### 小结

- 二分查找的时间复杂度是 `O(logn)`，这也是分治法普遍具备的特性。当你面对某个代码题，而且约束了时间复杂度是 `O(logn)` 或者是 `O(nlogn)` 时，可以想一下分治法是否可行。
- 二分查找的循环次数并不确定。一般是达到某个条件就跳出循环。因此，编码的时候，多数会采用 while 循环加 break 跳出的代码结构。
- **二分查找处理的原问题必须是有序的**。因此，当你在一个有序数据环境中处理问题时，可以考虑分治法。相反，如果原问题中的数据并不是有序的，则使用分治法的可能性就会很低了。

## 区间左闭右开

数学上区间有：

- 双闭 `0 <= x <= 3`
- 双开 `-1 < x < 4`
- 左闭右开 `0 <= x < 4`
- 左开右闭 `-1 < x <= 3`

Dijkstra 早在 1982 年就对这 4 种区间表示方法的优劣进行了论述，结论是左闭右开是表示区间最友好最出色的方式，原因如：

1. 上下界之差直接表示元素的个数
2. 在表示两个相邻子序列时相当方便和简洁：一个子序列的上界就是另一个子序列的下界
3. 当上界等于下界时即可表示空集，不会出现上界小于下界的情况。而双闭在表示空集时必然需要上界小于下界，比较难看，如 `0 <= x <= -1`

## 对数时间复杂度

这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 `O(1)` 的算法还要高效: `O(1)`有可能表示的是一个非常大的常量值，比如`O(1000)`、`O(10000)`

## 二分查找思路

- 循环条件：左右指针相遇
- 目标所在区间判断

## 二分查找易错点

- 循环退出条件：`n <= m`
- mid 取值算法：`n + (m-n) >> 1`
- low 和 high 的更新: `low = mid + 1`, `high = middle - 1`

## 二分查找场景的局限性

### 数据结构采用顺序表结构(简单来说就是：数组)

二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。我们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是 O(1)，而*链表随机访问的时间复杂度是`O(n)`*。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。

### 二分查找针对的是有序数据

二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。我们知道，排序的时间复杂度最低是`O(nlogn)`。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行**一次排序，多次二分查找**。这样排序的**成本可被均摊**，二分查找的边际成本就会比较低。

但是，如果我们的数据集合*有频繁的插入和删除操作*，要想用二分查找，

- 要么每次插入、删除操作之后保证数据仍然有序，
- 要么在每次二分查找之前都先进行排序

针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。

> 针对动态数据集合，可以使用**二叉树数据结构**来解决这个问题

### 数据量太小不适合二分查找。

如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。只有**数据量比较大**的时候，二分查找的优势才会比较明显。

如果**数据之间的比较操作**非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。

### 数据量太大也不适合二分查找

二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻

### 实现

- 递归实现
- 非递归实现(循环)

## 思考题

- 如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？

  > 假设链表长度为`n`，二分查找每次都要找到中间点(计算中忽略奇偶数差异):
  > 第一次查找中间点，需要移动指针 `n/2` 次；
  > 第二次，需要移动指针`n/4` 次；
  > 第三次需要移动指针`n/8` 次；
  > ......
  > 以此类推，一直到 1 次为值

  > 总共指针移动次数(查找次数) = `n/2 + n/4 + n/8 + ...+ 1`，这显然是个等比数列，根据等比数列求和公式：`Sum = n - 1`

  > 最后算法时间复杂度是：`O(n-1)`，忽略常数，记为 `O(n)`，时间复杂度和顺序查找时间复杂度相同
  > 但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢

- 查询 IP 归属地
  > ip 地址转化为整数，从小到大排序，构建 ip-地址信息库，再进行二分查找
- 有序数组是一个循环有序数组，比如`4, 5, 6, 1, 2, 3`。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？
  > [binary-search.ts](./binary-search.ts#L206)

## Reference

- [wiki 二分查找算法](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95)
- [Why numbering should start at zero](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)
- [数据结构与算法之美 - 二分查找](https://time.geekbang.org/column/article/42520)
- [分治：如何利用分治法完成数据查找](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=185#/detail/pc?id=3350)
