import BinarySearchTree from './BinarySearchTree'
import { describe, test, expect, it } from '@jest/globals'

describe('BinarySearchTree', () => {
  test('test for in order traverse', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    const nodes: number[] = []
    const getNode = (value: number) => nodes.push(value)
    tree.inOrderTraverse(getNode)
    expect(nodes).toMatchObject([3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 20, 25])
  })
  test('test for pre order traverse', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    const nodes: number[] = []
    const getNode = (value: number) => nodes.push(value)
    tree.preOrderTraverse(getNode)
    expect(nodes).toMatchObject([11, 7, 5, 3, 6, 9, 8, 10, 15, 13, 12, 14, 20, 18, 25])
  })
  test('test for post order traverse', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    const nodes: number[] = []
    const getNode = (value: number) => nodes.push(value)
    tree.postOrderTraverse(getNode)
    expect(nodes).toMatchObject([3, 6, 5, 8, 10, 9, 7, 12, 14, 13, 18, 25, 20, 15, 11])
  })
  test('get the min node', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    expect(tree.min().key).toEqual(3)
    tree.insert(2)
    tree.insert(4)
    expect(tree.min().key).toEqual(2)
  })
  test('get the max node', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    expect(tree.max().key).toEqual(25)
    tree.insert(27)
    tree.insert(30)
    expect(tree.max().key).toEqual(30)
  })
  test('the number 8 is in the tree', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    expect(tree.search(8)).toBe(true)
  })
  test("the number 100 isn't in the tree", () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    expect(tree.search(100)).toBe(false)
  })
  it('remove node with no left and right node', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    const nodes: number[] = []
    const getNode = (value: number) => nodes.push(value)
    tree.remove(6)
    tree.inOrderTraverse(getNode)
    expect(nodes).toMatchObject([3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 20, 25])
  })
  it('remove node with only left node', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(3)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    const nodes: number[] = []
    const getNode = (value: number) => nodes.push(value)
    tree.remove(5)
    tree.inOrderTraverse(getNode)
    expect(nodes).toMatchObject([3, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 20, 25])
  })
  it('remove node with only right node', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(15)
    tree.insert(5)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    const nodes: number[] = []
    const getNode = (value: number) => nodes.push(value)
    tree.remove(5)
    tree.inOrderTraverse(getNode)
    expect(nodes).toMatchObject([6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 20, 25])
  })
  it('remove node which have both left and right node', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(3)
    tree.insert(15)
    tree.insert(5)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    const nodes: number[] = []
    const getNode = (value: number) => nodes.push(value)
    tree.remove(5)
    tree.inOrderTraverse(getNode)
    expect(nodes).toMatchObject([3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 20, 25])
  })
  it('remove node which have both left and right node', () => {
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(7)
    tree.insert(3)
    tree.insert(15)
    tree.insert(5)
    tree.insert(9)
    tree.insert(8)
    tree.insert(10)
    tree.insert(13)
    tree.insert(12)
    tree.insert(14)
    tree.insert(20)
    tree.insert(18)
    tree.insert(25)
    tree.insert(6)
    const nodes: number[] = []
    const getNode = (value: number) => nodes.push(value)
    tree.remove(15)
    tree.inOrderTraverse(getNode)
    expect(nodes).toMatchObject([3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 18, 20, 25])
  })
})
